// kotlin 강좌 #!8 클래스의 다형성

// 클래스의 다형성을 이용하는 법
// 다형성의 개념과 이를 이용하는 법을 알아보자

// 이미 우리는 '클래스의 상속'을 통해 클래스를 '확장'하는 법을 배웠다.
// 하지만 클래스를 다형성(Polymorphysm)의 관점에서 살펴본 적은 없다.
// 예를 들어 음료를 마시는 일에 비유를 해보자.
// 그냥 목이 말라서 아무 음료나 마셔도 좋을 때도 있지만 기호에 맞춰 콜라,커피,생수 등 원하는 음료를 선택할 때도 있겠죠?
// 이 때 , 콜라를 '콜라 자체'로도 볼 수 있지만 '음료라는 특성'으로도 볼 수 있도록 만드는 것이 '다형성'의 개념이다.
// 코틀린의 내부동작을 들여다 보자.
// 음료라는 클래스와 이를 상속받은 콜라라는 클래스가 있다면 콜라의 인스턴스를 만들때는 상속관계에 있는 수퍼클래스인
// 음료의 내용을 담는 공간에 콜라의 내용을 담는 공간이 추가되어 생성된다. 이렇게 만들어진 콜라의 인스턴스는
// 음료를 담는 변수에 저장하면 음료의 기능만 사용하게 되고 var a: Drink = Cola()
// 콜라를 담는 변수에 저장하면 콜라의 기능까지 모두 사용할 수 있다. var a: Cola = Cola() *타임추론 기능으로 Cola 자료형은 생략가능

// 이때, 콜라 인스턴스를 음료변수에 담는 행위를 상위 자료형인 수퍼클래스로 변환한다고 하여 Up-Casting이라고 하고
// Up-Casting 된 인스턴스를 다시 하위자료형으로 변환하면 Down-Casting 이라 부른다.
// 사실 Up-Casting은 var a: Drink = Cola() 그냥 상위자료형에 담는것으로 동작하지만
// Down-Casting은 '별도의 연산자'가 필요하다. 바로 as 와 is 연산자다.

// 'as'는 변수를 호환되는 자료형으로 변환해주는 캐스팅 연산자로 코드내에서 사용할시 즉시 자료형을 변환해주며 변환된 자료형을 반환도 해주는 연산자다.
// ex) var a: Drink = Cola()
//    a as Cola    >>>>> 이후로는 a는 Cola로 동작함   var b = a as Cola >>>>>>>>>>> Cola로 변환한 결과를 반환받아 변수에 넣을 수도 있음

// 'is'는 변수가 자료형에 호환되는지를 먼저 '체크한 후 변환'해주는 캐스팅 연산자로 '조건문내'에서 사용되는 특징이 있다.
// ex) var a: Cola = Cola()
//     if(a is Cola) {   }   >>>>>>>>>>> 조건문 안에서만 a가 Cola가 됨

// 실습 ㄱㄱ


// 먼저 Drink 클래스를 상속이 가능한 open class로 만들어 준다.
// 속성으로 name이라는 변수에 음료라는 문자열을 할당해보자.
// 그리고 drink라는 함수를 만들되 override가 가능하도록 open해준다.
// 내용에는 'name'이라는 변수에 마십니다 라고 출력해보자.

// 다음은 Cola라는 클래스를 Drink를 상속받아 만들어보자
// type이라는 변수를 만들어 콜라 라는 문자열을 할당하고
// drink 함수를 override하여 'name'중에 'type'을 마십니다 라고 출력해보자

// 다음 washDishes 함수를 추가하여 'type'으로 설거지를 합니다라고 출력해보자.

// main에서는 먼저 Drink의 인스턴스를 만들어 a에 담고 a의 drink라는 함수를 호출해보자

// 먼저 한 번 실행해보자.
// Drink의 인스턴스에 있는 함수 drink함수를 호출했기 때문에 음료를 마십니다라고 출력된다.

// 그럼 추가로 Cola의 인스턴스를 만들어 Drink 타입에 변수 b를 할당하고 b의 drink라는 함수를 호출해보자
// 실행해보면 b는 Drink타입의 변수지만 Cola의 인스턴스를 담았으므로 Cola에서 override한 함수가 실행되는 것을 볼 수 있다.
// 하지만 b는 Drink변수 이므로 이대로는 washDishes 함수를 호출할 수 없다.
// 실제로 구문을 작성해보면 b.washDishes() >>> 참조할 수 없다는 에러가 뜬다.

// 이때는 is나 as를 통해 '다운캐스팅'을 해야한다.

// 먼저 if문을 추가하여 b is Cola 라는 구문으로 b가 Cola와 호환되는지 여부를 확인하고
// 중괄호 안에서 b의 washDishes함수를 호출해보자.  **  is는 조건문 안에서만 잠시 다운캐스팅된다는 점 잊지마세용~~!
// 실행해보면 콜라로 설거지를 합니다 라고 출력

// 이번엔 b as Cola로 다운캐스팅한것을 변수 c에 할당하자.
// 그리고 c에서 washDishes함수를 호출해보자.  >>>   콜라로 설거지를 합니다 출력

// 그런데 이때 맨아래에 b에서 washDishes 함수를 호출하는 구문을 넣어보자.
// 아까(52번줄)와 달리 참조할 수 없다는 에러가나지 않죠? 이는 as를 사용하면 반환값 c , as 뿐만 아니라 변수 b 자체도 다운캐스팅 되기 때문이다.



fun main() {
    var a = Drink()
    a.drink()

    var b: Drink = Cola()
    b.drink()

    if(b is Cola) {
        b.washDishes()
    }

    var c = b as Cola
    c.washDishes()
    b.washDishes()
}



open class Drink {
    var name = "음료"

    open fun drink() {
        println("${name}를 마십니다")
    }
}

class Cola: Drink() {
    var type = "콜라"

    override fun drink() {
        println("${name}중에 ${type}을 마십니다")
    }

    fun washDishes() {
        println("${type}으로 설거지를 합니다")
    }
}


// 다형성은 클래스의 상속관계에서 오는 인스턴스의 호환성을 적극 활용할 수 있는 기능으로 수퍼클래스가 같은 인스턴스를 한 번에 관리하거나
// 인터페이스를 구현하여 사용하는 코드에서도 이용되는 이해가 꼭!! 필요하다!!