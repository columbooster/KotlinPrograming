// kotlin 가좌 #11 오버라이딩과 추상화

// 상속시에는 기본적으로 수퍼클래스에 있는 함수와 같은이름과 형태를 가진 함수는 서브클래스에서는 만들 수 없다.
// 하지만 수퍼클래스에서 '허용'만 한다면 "오버라이딩(overriding)이라는 방법으로 서브클래스에서 같은 이름과 형태로된 함수의 내용을 다시 구현할 수 있다.

// 먼저 상속이 가능하게 open된 Animal 클래스를 만들고 클래스 내에 음식을 먹을 때 실행할 eat 함수를 만들어보자. 그 안에서 음식을 먹습니다라고 출력해보자.
// 그리고 Tiger 클래스를 만들어 이 클래스를 상속 받아 보자.
// 이 상태에서 Tiger의 인스턴스를 만들고 eat을 실행해보면 "음식을 먹습니다"를 출력한다.
// 그런데 Tiger 클래스에서는 음식을 먹습니다 대신 "고기를 먹습니다"라고 출력하고 싶다고 해보자.
// 하지만 이미 eat 함수는 Animal 에서 음식을 먹습니다라고 구현되어 있기 때문에 서브클래스에서는 함수를 "재구현 할 수 없다"
// 이 때, Animal 클래스에서 "eat함수 앞에" "open"이 붙어 있었다면 Tiger에서 "재구현이 허용"된다.
// 수퍼클래스에서 'open'이 붙은 함수는 서브클래스에서 "override"를 붙여 재구현 하면 된다.
// 여기서는 "고기를 먹습니다"를 대신 출력하도록 해보자.
// 이제 타이거에서 eat을 다시 수행시켜보면 "음식"대신 "고기"가 출력된다

// 이 사례에서는 이미 수퍼클래스에서 구현이 끝난 함수를 "오버라이딩을 통해 재구현"하는 경우를 해보았다.

/*
fun main() {
    var t = Tiger()

    t.eat()

}

open class Animal {
    open fun eat() {
        println("음식을 먹습니다")
    }
}

class Tiger : Animal() {
    override fun eat() {
        println("고기를 먹습니다")
    }
}
*/

// 이번엔 오버라이딩과 다르게 수퍼클래스에서는 함수의 구체적인 구현은 없고 단지 Animal의 모든 서브클래스는 eat이라는 함수가
// "반드시 있어야 한다"는 점만 명시하여 각 서브클래스가 비어있는 함수의 내용을 필요에 따라 구현하도록 하려면 "추상화"라는 개념을 사용한다.

// 추상화 ( abstraction ) 는 선언부만 있고 기능이 구현되지 않은 추상함수(abstraction function) ,그리고 추상함수를 포함하는 추상클래스(abstraction class)라는 요소로 구성된다.

// 그럼 추상함수를 포함한 추상클래스를 만들고 서브클래스에서 상속받아 구현까지 하는 과정을 알아보자

// 이번엔 Animal 클래스를 다시 만들되 그 앞에 abstract를 붙여줍니다.
// 그리고 추상함수인 eat함수를 만드는데 그 앞에서 abstract를 붙이고 함수의 내용은 적지 않는다. ** 추상함수는 비어있는 껍데기라고 생각하자!!
// 또한 일반함수로 냄새를 맡는 sniff함수를 추가하고 킁킁 거리도록 출력하도록 해보자
// 이렇게 abstract를 붙인 추상클래스는 일부 함수가 구현되지 않은 "미완성 클래스"이기 때문에 단독으로는 인스턴스를 만들 수 없다.
// 따라서 "반드시 서브클래스에서 상속"을 받아 "abstract 표시"가 된 함수들을 구현해줘야 한다.
// Rabbit이라는 클래스를 만들어 Animal을 상속 받고 eat이라는 추상함수의 "실제 동작되는 구현부"를 만들어보자
// Rabbit의 인스턴스를 만들어 eat과 sniff를 수행하도록 하면
/*
fun main() {
    var r = Rabbit()

    r.eat()
    r.sniff()

}

abstract class Animal {
    abstract fun eat()
    fun sniff() {
            println("킁킁")
        }

}

class Rabbit : Animal() {
    override fun eat() {   //override 키워드 잊지마라!!!
        println("당근을 먹습니다")
    }
}
*/

// 그런데 추상화를 하는 또 다른 방법이 있다. 바로 인터페이스 ( interface)라는 기능이다.
// 다른 언어들에서는 원래 인터페이스는 추상함수로만 이루어져있는 '순수 추상화 기능'을 말하는 것이라고 알텐데
// kotlin 에서는 인터페이스 역시 추상함수와 일반함수 모두를 가질 수 있다. 인터페이스(속성,추상함수,일반함수)
// 다만 추상함수는 생성자를 가질 수 있는 반면 인터페이스는 생성자를 가질 수는 없으며
// 인터페이스에서 구현부가 있는 함수는 -> open 함수로 간주
//              구현부가 없는 함수는 -> abstract 함수로 간주          하기 때문에 별도의 키워드(open, abstract)가 없어도
// 포함된 모든 함수를 서브클래스에서 구현 및 재정의가 가능하다.
// 또한 한 번에 여러 인터페이스를 상속받을 수 있으므로 좀 더 유연한 설계가 가능하다. ex) 인터페이스 a --> 서브클래스 a b <--인터페이스 b

// 그럼 인터페이스 2개를 한 번에 상속받는 클래스를 만들어 보자.
// 먼저 Runner 라는 인터페페이스를 만들고 run이라는 함수를 구현부 없이 만들어보자.
// 또한 Eater라는 인터페이스를 만들고 eat라는 함수를 음식을 먹습니다 출력해보자

// 이제 Dog 라는 클래스로 두 인터페이스를 상속받으려면 클래스 선언 뒤에 : 콜론을 붙이고 쉼표로 두 인터페이스를 구분하여 표기한다.

// 그리고 구현부가 없던 run 함수에는 override를 붙여 우다다다 뜁니다를 출력하도록 구현하고
// 이미 구현이 있는 eat이 라는 함수는 override를 붙여 허겁지겁 먹습니다를 출력하도록 재구현 해준다.
// 이렇게 하면 Dog는 두 인터페이스의 형식을 모두 물려받아 사용하는 서브클래스가 되는것이다.


fun main() {
    var d = Dog()

    d.run()
    d.eat()

}

interface Runner {
    fun run()
}

interface Eater {
    fun eat() {
        println("음식을 먹습니다")
    }
}

class Dog : Runner, Eater {
    override fun run() {
        println("우다다다 뜁니다")
    }

    override fun eat() {
        println("허겁지겁 먹습니다")
    }
}


// 한가지 주의해야할 점은 여러개의 인터페이스나 클래스에서 같은 이름과 형태를 가진 함수를 구현하고 있다면 서브클래스에서는 혼선이 일어나지 않도록
// 반드시 오버라이딩하여 재구현햐 주어야 한다.

// 오버라이딩은 이미 구현이 끝난 함수의 기능을 서브클래스에서 변경해야 할때
// 추상화는 형식만 선언하고 실제 구현은 서브클래스에 일임할 때 사용하는 기능
// 인터페이스는 서로 다른 기능들을 여러개 물려주어야 할 때 유용한 기능